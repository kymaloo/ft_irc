# SOCKETS #

socket			:	int socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0); 														// init SOCKET (Sockets created with the socket() function are initially unnamed; they are identified only by their address family. see:bind())
close			:	int close(int fildes);																						// close SOCKET
setsockopt		:	int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len); 	// set the option specified by the option_name argument, at the protocol level specified by the level argument, to the value pointed to by the option_value argument for the socket associated with the file descriptor specified by the socket argument.
getsockname		:	int getsockname(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len); 			// retrieve the locally-bound name of the specified socket, store this address in the sockaddr structure pointed to by the address argument, and store the length of this address in the object pointed to by the address_len argument.

# SOCKET ADRESSES #

getprotobyname	:	struct protoent *getprotobyname(const char *name);																// returns a protoent structure for the entry from the database that matches the protocol name name. A connection is opened to the database if necessary. 
gethostbyname	:	struct hostent *gethostbyname(const char *name);																// returns a structure of type hostent for the given host name.

getaddrinfo		:	int getaddrinfo(const char  *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res);	// translates the name of a service location (for example, a host name) and/or a service name and returns a set of socket addresses and associated information to be used in creating a socket with which to address the specified service. 
freeaddrinfo	:	void freeaddrinfo(struct addrinfo *ai);																				// frees one or more addrinfo structures returned by getaddrinfo(), along with any additional storage associated with those structures.


# SOCKET ACTIONS #

bind			:	int bind(int socket, const struct sockaddr *address, socklen_t address_len);					// assign a local socket address address to a socket identified by descriptor socket that has no local socket address assigned.
connect			:	int connect(int socket, const struct sockaddr *address, socklen_t address_len);					// attempt to make a connection on a socket.
listen			:	int listen(int socket, int backlog);															// mark a connection-mode socket, specified by the socket argument, as accepting connections.
accept			:	int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len);		// extract the first connection on the queue of pending connections, create a new socket with the same socket type protocol and address family as the specified socket, and allocate a new file descriptor for that socket.




# CONVERTERS #

htons			:	uint16_t htons(uint16_t hostshort);		// converts the unsigned short integer hostshort from host byte order to network byte order. 
htonl			:	uint32_t htonl(uint32_t hostlong);		// converts the unsigned integer hostlong from host byte order to network byte order.
ntohs			:	uint16_t ntohs(uint16_t netshort);		// function converts the unsigned short integer netshort from network byte order to host byte order.
ntohl			:	uint32_t ntohl(uint32_t netlong);		// converts the unsigned integer netlong from network byte order to host byte order.

# ADRESSES #

inet_addr		:	in_addr_t inet_addr(const char *cp);											// convert the string pointed to by cp, in the standard IPv4 dotted decimal notation, to an integer value suitable for use as an Internet address.
inet_ntoa		:	char *inet_ntoa(struct in_addr in);												// convert the Internet host address specified by in to a string in the Internet standard dot notation.
//returns usable address
inet_ntop		:	const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);		// converts a numeric address into a text string suitable for presentation. (RETURN IP ADDRESS (const char*))
//returns printable address

"sockaddr_in" is the data type that is used to store the address of the socket.


# INTERACTIONS #

send			:	send(s, buf, sizeof buf, flags);	// send DATA
recv			:	recv(s, buf, sizeof buf, flags);	// receive DATA


# SIGNAL # 			// help //

signal			:	void (*signset(sigset_t *set, int signo);																	// pas compris	// deletes the individual signal specified by signo from the signal set pointed to by set.
sigismember		:	int sigismember(const sigset_t *set, int signo);															// pas compris	// tests whether the signal specified by signo is a member of the set pointed to by set.


# READ/ACT INTO FDS OR IDK #

lseek			:	off_t lseek(int fd, off_t offset, int whence);			// help // https://man7.org/linux/man-pages/man2/lseek.2.html
fstat			:	int fstat(int fildes, struct stat *buf);				// obtain information about an open file associated with the file descriptor fildes, and write it to the area pointed to by buf.
fcntl			:	int fcntl(int fildes, int cmd, ...);					// perform the operations described below on open files. // check here ==> // https://pubs.opengroup.org/onlinepubs/007904975/functions/fcntl.html
poll			:	poll(struct pollfd fds[], nfds_t nfds, int timeout);	// check FDS for in/out readyness


al(int sig, void (*func)(int)))(int);																			// ????? signal(sig, SIG_DFL); ?????
sigaction		:	int sigaction(int signum, const struct sigaction *_Nullable restrict act, struct sigaction *_Nullable restrict oldact);		// change action done when SIGNAL received
sigemptyset		:	int sigemptyset(sigset_t *set);																				// pas compris	// initialises the signal set pointed to by set, such that all signals defined in this document are excluded.
sigfillset		:	int sigfillset(sigset_t *set);																				// pas compris	// initialises the signal set pointed to by set, such that all signals defined in this document are included.
sigaddset		:	int sigaddset(sigset_t *set, int signo);																	// pas compris	// adds the individual signal specified by the signo to the signal set pointed to by set. 
sigdelset		:	int sigdelset(sigset_t *set, int signo);																	// pas compris	// deletes the individual signal specified by signo from the signal set pointed to by set.
sigismember		:	int sigismember(const sigset_t *set, int signo);															// pas compris	// tests whether the signal specified by signo is a member of the set pointed to by set.


# READ/ACT INTO FDS OR IDK #

lseek			:	off_t lseek(int fd, off_t offset, int whence);			// help // https://man7.org/linux/man-pages/man2/lseek.2.html
fstat			:	int fstat(int fildes, struct stat *buf);				// obtain information about an open file associated with the file descriptor fildes, and write it to the area pointed to by buf.
fcntl			:	int fcntl(int fildes, int cmd, ...);					// perform the operations described below on open files. // check here ==> // https://pubs.opengroup.org/onlinepubs/007904975/functions/fcntl.html
poll			:	poll(struct pollfd fds[], nfds_t nfds, int timeout);	// check FDS for in/out readyness




# Cahier des Charges #


1    L'API socket() renvoie un descripteur de socket qui représente un noeud final. L'instruction identifie également que la famille d'adresses AF_INET6 (Internet Protocol version 6) avec le transport TCP (SOCK_STREAM) est utilisée pour ce socket.

2    L'API setsockopt() permet à l'application de réutiliser l'adresse locale lorsque le serveur est redémarré avant l'expiration du délai d'attente requis.

3    L'API ioctl() définit le socket comme non bloquant. Toutes les sockets des connexions entrantes sont également non bloquantes car elles héritent de cet état du socket d'écoute.

4    Une fois le descripteur de socket créé, l'API bind() obtient un nom unique pour le socket.

5    L'appel API listen() permet au serveur d'accepter les connexions client entrantes.

6    L'API poll() permet au processus d'attendre qu'un événement se produise et de réveiller le processus lorsque l'événement se produit. L'API poll () peut renvoyer l'une des valeurs suivantes.

    0
        Indique que le processus dépasse le délai d'attente. Dans cet exemple, le délai d'attente est fixé à 3 minutes (en millisecondes).
    -1
        Indique que le processus a échoué.
    1
        Indique qu'un seul descripteur est prêt à être traité, qui n'est traité que s'il s'agit du socket d'écoute.
    1++
        Indique que plusieurs descripteurs sont en attente de traitement. L'API poll () permet la connexion simultanée avec tous les descripteurs de la file d'attente sur le socket d'écoute.



7    Les API accept() et recv() sont terminées lorsque le bloc EWOULDBLOCK est renvoyé.

8    L'API send() renvoie les données au client.

9    L'API close() ferme tous les descripteurs de socket ouverts.



## poll ##

# Événements possibles :

    À surveiller (events) :

        POLLIN : prêt à lire

        POLLOUT : prêt à écrire

        POLLERR : erreur (souvent implicite)

        POLLHUP : déconnexion (pipe/sock fermé)

        POLLNVAL : fd invalide

    Résultats (revents) :

        poll() remplit ce champ avec les événements détectés.


* admettons :

events = POLLIN | POLLOUT;

veut dire que :
POLLIN   = 0000 0001
POLLOUT  = 0000 0100
-------------------
events  = 0000 0101

* donc :

if (events & POLLIN)

events = 0000 0101
POLLIN  = 0000 0001
-------------------
Résultat = 0000 0001  (!= 0, donc vrai)
